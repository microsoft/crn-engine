// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

[<JavaScript>]
module Parser

open System

(* TODO: FParsec is mapping \n \r\n and \r all to \n, we are not doing that yet *)

type pos = int * int
type parse_state = string * pos
type Result<'a> = OkEmpty      of 'a * parse_state
                | OkConsumed   of 'a * parse_state
                | FailEmpty    of string * pos
                | FailConsumed of string * pos
type t<'a> = parse_state -> Result<'a>

type ParserResult<'a> = // Map our parser results to types that look like FParsec's
  | Success of 'a * string * pos
  | Failure of string * string * string

let start_pos = 0, 0
let mk_error err (r,c) message  = (message, (r,c)) |> err
let mk_failEmpty    pos str     = mk_error FailEmpty    pos str
let mk_failConsumed pos str     = mk_error FailConsumed pos str 

let add_cols n (r:int, c:int) = (r, c + n)
let add_rows n (r:int, c:int) = (r + n, c)
let add_row = add_rows 1
let isLetter = System.Char.IsLetter
let isLower = System.Char.IsLower
let isDigit = System.Char.IsDigit
let isWhiteSpace = System.Char.IsWhiteSpace

let lineSeparators = [|"\r\n";"\n"|]
let private CommentSingle = "//"
let private CommentStart  = "(*"
let private CommentEnd    = "*)"

let move (s:string) (r:int, c:int) =
  let rows = s.Split(lineSeparators, System.StringSplitOptions.None)
  let rs = rows.Length - 1
  let cs = rows.[rs].Length
  (r + rs, if rs = 0 then c + cs else cs)

(* The error message combinator, returns the error message "msg" when "parser" fails.
   Typically msg is some more meaningful error message than the one automatically 
   generated by "parser".*)
let (<?>) (parser:t<'a>) msg = fun st ->
  match parser st with
  | FailEmpty (_, p)    -> FailEmpty    (msg, p)
  | FailConsumed (_, p) -> FailConsumed (msg, p)
  | x                   -> x

let newline : t<char> = fun (s:string, (px, py):pos) ->
  if s.StartsWith "\n" then ('\n', (s.Substring 1, (px+1, 0) )) |> OkConsumed
  elif s.StartsWith "\r\n" then ('\n', (s.Substring 2, (px+1, 0))) |> OkConsumed
  elif s.StartsWith "\r" then ('\n', (s.Substring 1, (px+1, 0))) |> OkConsumed
  else "linebreak" |> mk_failEmpty (px, py)

let eof (s,p) =
  match s with
  | "" -> OkEmpty ((), ("",p))
  | _ -> "end of input" |> mk_failEmpty p

(* FParsec reimplementation *)
let satisfy pred = fun (s:string,p:pos) ->
  match s |> Seq.tryHead with
  | Some c -> // TODO check for newlines here
      if pred c then
        OkConsumed (c, (s.Substring(1, s.Length-1), add_row p))
      else FailEmpty (s,p)
  | None -> FailEmpty (s,p)

let manySatisfy pred : t<string> = fun (s:string,p:pos) ->
  match s.ToCharArray() |> Array.tryFindIndex (pred >> not) with
  | None -> OkEmpty (s, ("", p |> add_cols s.Length))
  | Some n ->
    let res, rest = s.Substring(0,n), s.Substring n
    if res.Length > 0
      then OkConsumed (res, (rest, p |> move res))
      else OkEmpty (res, (rest, p |> move res))

let many1Satisfy pred : t<string> = fun (s:string,p:pos) ->
  if s.Length > 0 && pred s.[0] then manySatisfy pred (s,p)
  else "a string satisying a predicate" |> mk_failEmpty p

let digits:t<string> = manySatisfy isDigit   <?> "an integer"
let digits1:t<string> = many1Satisfy isDigit <?> "an integer"

#if JavaScript
//WebSharper lacks an implementation of IndexOf : value:string * startIndex:int * count:int -> int
#else

let skipCharsTillString (str:string) skipString (maxCount:int) : t<string> = fun (s:string,p:pos) ->
  
  let furthest = min s.Length maxCount //TODO: Check this is correct on boundary conditions
  try
    let i = s.IndexOf(str,0,furthest)
    let res, taken, rest =
      if skipString then
        ( s.Substring (0,i)
        , s.Substring (0,i+str.Length)
        , s.Substring (i+str.Length) )
      else
        ( s.Substring (0,i)
        , s.Substring (0,i)
        , s.Substring i )
    if res.Length > 0
      then OkConsumed (res, (rest, p |> move taken))
      else OkEmpty (res, (rest, p |> move taken))
  with _ ->
    let res, rest = s.Substring(0,furthest), s.Substring furthest
    FailConsumed (rest, p |> move res)
#endif

let (>>=) (p:t<'a>) (f:'a -> t<'b>) : t<'b> = fun s -> 
  match p s with
  | OkEmpty (res, rest) -> f res rest
  | OkConsumed (res1, rest1) -> 
    match f res1 rest1 with
    | OkEmpty      (res2, rest2) -> OkConsumed   (res2, rest2)
    | OkConsumed   (res2, rest2) -> OkConsumed   (res2, rest2)
    | FailEmpty    (e, pos)      -> FailConsumed (e, pos)
    | FailConsumed (e, pos)      -> FailConsumed (e, pos)
  | FailEmpty    (e, pos) -> FailEmpty    (e, pos)
  | FailConsumed (e, pos) -> FailConsumed (e, pos)

(* lifts an x of type T to a parser of type T *)
let preturn         x = fun s -> OkEmpty    (x, s)
let preturnConsumed x = fun s -> OkConsumed (x, s)

let (|>>) (f:t<'a>) (m:'a -> 'b) : t<'b> = f >>= (m >> preturn)
let (>>%) f x = f |>> (fun _ -> x)
let (|~>) (p:t<'a>) (m:pos -> 'a -> 'b) : t<'b> = p >>= (fun v (str, pos) -> preturn (m pos v) <| (str, pos))

let skipNewline = newline |>> ignore

let pstring str (s:string, p) =
  if s.StartsWith str 
    then 
      OkConsumed (str, (s.Substring str.Length, p |> add_cols str.Length))
    else sprintf "\'%s\'" str |> mk_failEmpty p

let pstringkw str (s:string, p) =
  if s.StartsWith str then
    if s.Length = str.Length then
        OkConsumed (str, (s.Substring str.Length, p |> add_cols str.Length))
    else
        let lastChar = str.Chars(str.Length-1)
        if (isDigit lastChar) || (isLetter lastChar)  || (lastChar = '_') then
            let  nextChar = s.Chars(str.Length)
            if ((isDigit nextChar) || (isLetter nextChar) || (nextChar = '_')) then
                sprintf "\'%s\'" str |> mk_failEmpty p
            else
                OkConsumed (str, (s.Substring str.Length, p |> add_cols str.Length))
        else
            OkConsumed (str, (s.Substring str.Length, p |> add_cols str.Length))
            
  else sprintf "\'%s\'" str |> mk_failEmpty p

let skipString str = pstring str |>> ignore
let keyword = skipString // reads the input string, returns nothing

let opt f s =
  match f s with
  | OkConsumed (res, rest) -> OkConsumed (Some res, rest)
  | OkEmpty    (res, rest) -> OkEmpty    (Some res, rest)
  | FailEmpty _            -> OkEmpty (None, s)
  | FailConsumed (e, p)    -> FailConsumed (e, p)

(*
let (.>>.) (f1:t<'a>) (f2:t<'b>) : t<'a*'b> = fun s -> 
  match f1 s with
  | Ok (res1, rest1) ->
    (match f2 rest1 with
     | Ok (res2, rest2) -> Ok ((res1,res2),rest2)
     | Error (e,p) -> Error (e,p)
    )
  | Error (e,p) -> Error (e,p)
*)
  
let (>>>>) (f:t<'a>) (m:t<'b>) : t<'b> = f >>= (fun _ -> m)

let (.>>.) (f1:t<'a>) (f2:t<'b>) : t<'a*'b> = f1 >>= (fun v1 -> f2 >>= (fun v2 -> preturn (v1, v2)))
  

let (.>>) f1 f2 = f1 .>>. f2 |>> fst
let (>>.) f1 f2 = f1 .>>. f2 |>> snd
let (<|>) (f1:t<'a>) (f2:t<'a>) s =
  match f1 s with
  | FailEmpty (e1, _) -> 
    match f2 s with
    | FailEmpty (e2, p)   -> FailEmpty (e1 + " or " + e2, p)
    | x -> x    
  | x -> x

let linebreak : t<unit> = newline |>> ignore
  
let restOfLine skipNewline =
  let notLinebreak c = c <> '\n' && c <> '\r' 
  if skipNewline then (manySatisfy notLinebreak) .>> (linebreak <|> eof)
  else manySatisfy notLinebreak

(* the failure parser, which always throws an error with message "msg" *)
let failParser msg : t<'a> = fun (_,p) -> FailEmpty (msg, p)

(* Parsec's 'try' parser. If 'p' consume some input and fails, 
   'pTry p' fails without consuming any input. *)
let pTry (p : t<'a>) : t<'a>= fun (st:parse_state) ->
  match p st with
    | FailConsumed (e, p) -> FailEmpty (e, p)
    | x                   -> x

 
let lookAhead (s:string) (text:string, pos) : Result<unit> =
  if text.StartsWith s
    then OkEmpty   ((), (text, pos))
    else FailEmpty (s, pos)

let plookAhead (p:t<'a>) (str, pos) =
  let st = str, pos
  match p st with
    | OkEmpty             _  -> OkEmpty   ((), st)
    | OkConsumed          _  -> OkEmpty   ((), st)
    | FailEmpty     (msg, _) -> FailEmpty (msg, pos)
    | FailConsumed  (msg, _) -> FailEmpty (msg, pos)

let plookAheadWith (p:t<'a>) (str, pos) =
  let st = str, pos
  match p st with
    | OkEmpty       (res, _) -> OkEmpty   (res, st)
    | OkConsumed    (res, _) -> OkEmpty   (res, st)
    | FailEmpty     (msg, _) -> FailEmpty (msg, pos)
    | FailConsumed  (msg, _) -> FailEmpty (msg, pos)


let pipe3 f1 f2 f3 m = f1 .>>. f2 .>>. f3 |>> fun ((a,b),c) -> m a b c
let between a b f = a >>. f .>> b

(*
let applies s (f:t<'a>) =
  match f s with
   | Ok (res, rest) -> Some (res,rest)
   | Error _ -> None
*)
(*
let choice fs (s,p) =
  match Seq.tryPick (applies (s,p)) fs with
  | None -> "No choice applies" |> mk_error p
  | Some (res, rest) -> Ok (res,rest)
*)

let choice (fs:seq<t<'a>>) = 
  if Seq.isEmpty fs 
    then failParser "Malformed grammar, choice is empty."
    else let x, xs = Seq.head fs, Seq.skip 1 fs
         Seq.fold (<|>) x xs 


// fixpoint operator
let rec pfix (f:'a -> t<'a>) (a:'a) : t<'a> = 
  choice [ f a >>= pfix f
           preturn a      ]

(* Less elegant but better error reporting
let choice (fs:seq<t<'a>>) (s,p) =
  let rec loop error_acc =
    function
    | [] ->
       error_acc
       |> List.rev
       |> List.mapi (sprintf "%d: %s")
       |> String.concat "\n  "
       |> sprintf "No choice applies:\n [%s]"
       |> mk_error p
    | (f:t<'a>)::fs ->
      (match f (s,p) with
       | Ok (res, rest) -> Ok (res,rest)
       | Error (e,p) -> loop (e::error_acc) fs
      )
  loop [] (fs |> Seq.toList) *)

let rec many (f:t<'a>) state =
    match f state with
    | OkEmpty    (x, rest) -> (many f >>= (fun xs -> preturn         (x::xs))) rest
    | OkConsumed (x, rest) -> (many f >>= (fun xs -> preturnConsumed (x::xs))) rest
    | FailEmpty _          -> OkEmpty ([], state)
    | FailConsumed (e, p)  -> FailConsumed (e, p)

(*
let many (f:t<'a>) s =
  let rec loop acc s_rest =
    match f s_rest with
    | Ok (res, rest) -> loop (res :: acc) rest
    | Error _ -> Ok (acc |> List.rev, s_rest)
  loop [] s
*)

let rec manyTillRev acc (f:t<'a>) (pEnd:t<'b>) state =
    match pEnd state with
    | OkEmpty    (_, rest) -> OkEmpty (acc, rest)
    | OkConsumed (_, rest) -> OkConsumed(acc, rest)
    | FailEmpty  _ -> 
        match f state with
        | OkEmpty    (x, rest1)
        | OkConsumed (x, rest1) -> 
            let acc' = x :: acc
            manyTillRev acc' f pEnd rest1
        | FailEmpty    (e, pos) -> FailEmpty    (e, pos)
        | FailConsumed (e, pos) -> FailConsumed (e, pos)
    | FailConsumed (s, pos)  -> FailConsumed (s, pos)

let rec manyTill (f:t<'a>) (e:t<'b>) = manyTillRev [] f e >>= (List.rev >> preturn)

//let rec manyTill (f:t<'a>) (e:t<'b>) state =
//    match e state with
//    | OkEmpty    (x, rest) -> OkEmpty ([], rest)
//    | OkConsumed (x, rest) -> OkConsumed([], rest)
//    | FailEmpty  _ -> (f >>= (fun x -> manyTill f e >>= (fun xs -> preturn (x::xs)))) state
//    | FailConsumed (s, pos)  -> FailConsumed (s, pos)

let many1 f = (f .>>. many f) |>> List.Cons

let sepBy1 f sep = (f .>>. many (sep >>. f)) |>> List.Cons
let sepBy2 f sep = (f .>>. many1 (sep >>. f)) |>> List.Cons
let sepBy f sep = (sepBy1 f sep |> opt) |>> function None -> [] | Some l -> l
let sepEndBy1Try f sep = (f .>>. many (pTry (sep >>. f)) |>> List.Cons) .>> opt sep
let sepEndByTry  f sep = opt (sepEndBy1Try f sep) |>> function None -> [] | Some l -> l
let sepEndBy1    f sep = sepEndBy1Try f sep //sepBy1 f sep .>> opt sep
let sepEndBy     f sep = sepEndByTry  f sep // opt (sepEndBy1 f sep) |>> function None -> [] | Some l -> l
let chainl1Try f op = (f .>>. many (pTry (op .>>. f))) |>> fun (r, oprs) -> List.fold (fun x (op, y) -> op x y) r oprs
let chainl1 f op = (f .>>. many (op .>>. f)) |>> fun (r, oprs) -> List.fold (fun x (op, y) -> op x y) r oprs
let sign:t<string> = opt (pstring "-") |>> function Some _ -> "-" | None -> ""
let forced_sign:t<string> = pstring "-" <|> pstring "+"
let opt_sign:t<string> = opt (pstring "-" <|> pstring "+") |>> function Some s -> s | None -> ""

let do_guarded (s:string) (r_s:string, r_p) m ok = 
  let n = s.Length - r_s.Length
  ok (s.Substring(0,n) |> m, (s.Substring n, r_p))

let guarded m (f:t<'a>) (s:string,p) =
  match f (s,p) with
  | OkEmpty    (_, rest) -> do_guarded s rest m OkEmpty
  | OkConsumed (_, rest) -> do_guarded s rest m OkConsumed
  | FailEmpty    (e, p)  -> FailEmpty    (e, p)
  | FailConsumed (e, p)  -> FailConsumed (e, p)

let pint32:t<int32> = pTry (sign .>>. digits1 )|> guarded int32
let pfloat:t<float> =
  pTry (sign .>>. digits1 .>>. opt (pstring "." >>. digits1) .>>. opt ((pstring "e" <|> pstring "E") >>. opt_sign .>>. digits1))
  |> guarded float <?> "a float"

let do_such_that pred res (s:string) (r_s:string, r_p) p ok err =
    if pred res then
      ok (res, (r_s, r_p))
    else
      let n = s.Length - r_s.Length
      s.Substring(0,n)
      |> sprintf "Predicate failed on %s"
      |> err p

let such_that pred (f:t<'a>) (s:string,p) =
  match f (s,p) with
  | OkEmpty (res, rest)    -> do_such_that pred res s rest p OkEmpty    mk_failEmpty
  | OkConsumed (res, rest) -> do_such_that pred res s rest p OkConsumed mk_failConsumed
  | FailEmpty    (e, p)    -> FailEmpty (e, p)
  | FailConsumed (e, p)    -> FailConsumed (e, p)

let attempt f = pTry f // our parsers do not change the state if they fail, we have a functional stream
(*
let run f s =
  match f (s, start_pos) with
  | Ok (res, (s,p)) -> Success (res, s, p)
  | Error (e,p) -> Failure (e, e, s)
*)

(******************************) 
(*** char parsing utilities ***)
(******************************)
let anyChar : t<char> = fun (s:string, (px, py):pos) ->
  let pos = (px, py)
  if s.Length > 0 && isLetter s.[0] 
    then 
      if   s.StartsWith "\n"   then ('\n', (s.Substring 1, (px+1, 0))) |> OkConsumed
      elif s.StartsWith "\r\n" then ('\n', (s.Substring 2, (px+1, 0))) |> OkConsumed
      elif s.StartsWith "\r"   then ('\n', (s.Substring 1, (px+1, 0))) |> OkConsumed
      else OkConsumed (s.[0], (s.Substring 1, add_cols 1 pos))
    else "a letter" |> mk_failEmpty pos

let pchar c : t<char> = fun (s:string,p:pos) ->
  if s.Length > 0 && s.[0] = c then OkConsumed (s.[0], (s.Substring 1, add_cols 1 p))
  else c |> string |> mk_failEmpty p

let manyChars (p: t<char>) = many p |>> List.map string |>> (String.concat "") //TODO: optimise

// skips a single char c if (pred c) holds:
let skipChar pred : t<unit> = fun (s:string,p:pos) ->
  if s.Length > 0 && pred s.[0]
    then 
      let pos' = if Array.contains (s.[0].ToString()) lineSeparators
                  then (fst p + 1, 0)
                  else add_cols 1 p
      OkConsumed ((), (s.Substring 1, pos'))
    else "a char satisying predicate" |> mk_failEmpty p

let whiteSpace : t<unit> = linebreak <|> skipChar isWhiteSpace <?> "a white space"
let anyChar_INTERNAL : t<unit> = skipChar (fun _ -> true) <?> "any char" //This is "INTERNAL" as it conflicts with FParsec's anyChar
let eol (* end of line *)   = (Array.map keyword lineSeparators |> choice) <|> eof

// parse zero or more p before delim
let rec  manyUntil (p:t<'a>) (delim:t<unit>) : t<'a list> =  fun st ->
  match delim st with
  | OkEmpty    (_, st') -> OkEmpty    ([], st')
  | OkConsumed (_, st') -> OkConsumed ([], st')
  | FailEmpty _         -> (p >>= fun x -> manyUntil p delim >>= (fun xs -> preturn (x::xs))) st
  | FailConsumed (e, p) -> FailConsumed (e, p)
                   
(* Same as manyUntil, but skips the input parser and throws away the result. 
   Solves a stack overflow issue with long comments *)
let rec skipUntil (p:t<'a>) (delim:t<unit>) : t<'a list> =  fun st ->
  match delim st with
  | OkEmpty    (_, st') -> OkEmpty    ([], st')
  | OkConsumed (_, st') -> OkConsumed ([], st')
  | FailEmpty _         -> (p >>>> skipUntil p delim) st // ">>>>" is tail recursive, ">>." accumulates p here
  | FailConsumed (e, p) -> FailConsumed (e, p)

//This wrapper is currently needed or WebSharper will fail to perform tail call optimisation
let commentMultilineShield (nestingOuter : int) =
  let rec doCommentMultiline (nesting : int) : t<unit> = fun (input:string, (px, py) : pos) ->
    let pos = (px, py)
    if   nesting = 0  then OkEmpty ((), (input, (px, py)))
    elif input = ""     then FailConsumed ("missing \"*)\" to close an open comment", (px, py))
    else let (nesting', state') =
           let csLen = CommentStart.Length
           let ceLen = CommentEnd.Length
           if input.StartsWith CommentStart   then (nesting + 1, (input.Substring csLen, add_cols csLen pos))
           elif input.StartsWith CommentEnd   then (nesting - 1, (input.Substring ceLen, add_cols ceLen pos))
           elif input.StartsWith "\r\n"       then (nesting, (input.Substring 2, (px+1, 0)))
           elif input.StartsWith "\r" 
                || input.StartsWith "\n"      then (nesting, (input.Substring 1, (px+1, 0)))
           else                                    (nesting, (input.Substring 1, add_cols 1 pos))
         in doCommentMultiline nesting' state'

  doCommentMultiline nestingOuter

// comment parsing
let commentLine = keyword CommentSingle >>>> manyUntil anyChar_INTERNAL (linebreak <|> eof) |>> ignore
//let doCommentMultiline nestingLevel = 
//  let currentNesting = ref nestingLevel
//  while !currentNesting > 0
//    do choice [ keyword CommentStart >>. (currentNesting := !currentNesting + 1; preturn ())
//                keyword CommentEnd   >>. (currentNesting := !currentNesting - 1; preturn ())  
//                eof >>. (currentNesting := 0; preturn ()
//                anyChar >>. 
//                ]
//  choice [  eof >>. failParser "missing \"*)\""
//            preturn () ]

let rec commentMultiline () = keyword CommentStart >>. commentMultilineShield 1
                             (* "fun _ ->" below is necessary to avoid "commentMultiline()" to diverge     
                                because of F#'s eager evaluation *)
                             // >>= fun _ -> skipUntil (commentMultiline() <|> anyChar_INTERNAL) (keyword CommentEnd)
                             |>> ignore


// space-related parsing
let spaces :t<string>  = fun st -> 
  match many  (commentLine <|> commentMultiline () <|> whiteSpace) <| st with
  | OkEmpty    (_, st') -> OkEmpty ("", st')
  | OkConsumed (_, st') -> OkEmpty ("", st')
  | FailEmpty _         -> OkEmpty ("", st)
  | FailConsumed (e, p) -> FailConsumed (e, p)
let spaces1:t<string> = fun st -> 
  match many1  (commentLine <|> commentMultiline () <|> whiteSpace) <| st with
  | OkEmpty    (_, st') -> OkEmpty ("", st')
  | OkConsumed (_, st') -> OkEmpty ("", st')
  | FailEmpty _         -> OkEmpty ("", st)
  | FailConsumed (e, p) -> FailConsumed (e, p)

// space-padded combinators
let (+>>+) f1 f2 = f1 .>>. (spaces >>. f2)  
let (+>>) f1 f2 = f1 +>>+ f2 |>> fst
let (>>+) f1 f2 = f1 +>>+ f2 |>> snd

// utils
let name = (many1Satisfy isLetter .>>. manySatisfy (fun c -> isLetter c || isDigit c || c = '_'|| c = '\'') |>> fun (a,b) -> a + b) <?> "an identifier"

let name_kw (keywords:string list) = pTry(name >>= fun(x) ->
                                if List.contains x keywords then
                                    failParser "Keyword found"
                                else 
                                    preturn x)
    
let kw s = pstringkw s .>> spaces
let skw s = spaces >>. kw s
let bracket l r = between (kw l) (spaces >>. kw r)
let paren a         = bracket "(" ")" a 
let sqBrackets a    = bracket "[" "]" a
let braces a        = bracket "{" "}" a
let angleBrackets a = bracket "<" ">" a
let sepEndBy1Amb p sepEnd sep = 
     ( (p .>> spaces >>= 
          fun x -> (manyUntil (sep >>>> p .>> spaces) 
                              (sepEnd <|> pTry (sep >>>> sepEnd) |>> ignore) 
                >>= fun xs -> preturn (x::xs) )))
let sepEndByAmb  p pEnd pSep = (pEnd >>>> preturn []) <|> sepEndBy1Amb p pEnd pSep

let list_of p = kw "[" >>>> sepEndByAmb p (kw "]") (kw ";") 
// sepEndBy p (skw ";") |> bracket "[" "]"
                                  
let list_of1 p =kw "[" >>>> sepEndBy1Amb p (kw "]") (kw ";") 
let tuple_of p = (sepBy2 p (skw ",") |> paren) <|> (p |>> fun v -> [v])

let pcolour:t<string> = 
        let p = manySatisfy (fun x -> isLetter x || isDigit x)
        pstring "\""
          >>. choice [ kw "#" >>. (many1Satisfy (fun x -> ('a' <= x && x <='f') || ('A' <= x && x <='F') || isDigit x)) >>= (fun x -> preturn ("#" + x))
                       p ]
          .>> kw "\""

let pbool:t<bool> = choice [ kw "true" >>% true
                           ; kw "True" >>% true
                           ; kw "false" >>% false
                           ; kw "False" >>% false ]

let record empty fields =
  kw "{" >>>> (sepEndByAmb
    (fields |> List.map (fun (n,p) -> kw n >>. (kw "=" >>. p) ) |> choice) 
    (kw "}")
    (skw ";")
    )
  |>> List.fold (fun r m -> m r) empty

let errMsg msg (r, c) = sprintf "Expecting %s at row %d column %d" msg (r+1) (c+1)

let do_run(f:t<'a>) s = (spaces >>. f .>> spaces) (s, start_pos)

let run (f:t<'a>) s =
  match do_run f s with
  | OkEmpty    (res, (s,p))  -> Success (res, s, p)
  | OkConsumed (res, (s,p))  -> Success (res, s, p)
  | FailEmpty    (e, p)      -> Failure (errMsg e p, e, s)
  | FailConsumed (e, p)      -> Failure (errMsg e p, e, s)

let run_result (f:t<'a>) s = (spaces >>. f .>> spaces) (s, start_pos)

// Note: the row here is 1-based.
type error = { row: int; column: int; text: string}
type Exception(msg:string, errors:error[]) =
  inherit System.Exception(msg)
  member e.Errors = errors

let from_string p s =
  match do_run p s with
  | OkEmpty    (res, ("",_))  
  | OkConsumed (res, ("",_))  -> res
  | OkEmpty    (res, (txt,(r,c)))  
  | OkConsumed (res, (txt,(r,c)))  -> raise (Exception( sprintf "Unexpected end of input at row %d column %d" r c, [|{row=r+1; column=c; text=sprintf "unexpected end of input at column %d" c}|] ))
  | FailEmpty    (e, (r,c))      
  | FailConsumed (e, (r,c))      -> raise (Exception( e, [|{row=r+1; column=c; text=e}|] ))

let from_string_first_error p s =
  match do_run p s with
  | OkEmpty    (_, ("",_))  
  | OkConsumed (_, ("",_)) -> None
  | OkEmpty    (_, (_,(row, column)))  
  | OkConsumed (_, (_,(row, column)))  
  | FailEmpty    (_, (row, column))      
  | FailConsumed (_, (row, column))    -> Some (row, column)

let from_string_first_error_with_msg p s =
  
  let getNextWordOnError text =
    let pNextWord = manySatisfy (fun c -> c <> ' ' && c <> '\n' && c <> '\r')
    match run pNextWord text with 
    | ParserResult.Success (w, _,_) -> sprintf "\'%s\'" w
    | ParserResult.Failure _        -> "input"

  let mkErrorRes msg row column expected = 
    let msg = sprintf "Unexpected %s." msg 
              + if expected <> "" 
                  then "\nExpecting: " + expected
                  else ""
    let e : error = { column  = column
                      row     = row
                      text    = msg   }
    Choice2Of2 e

  match do_run p s with
  (* Parsing succeeds *)
  | OkEmpty    (result, ("",_))  
  | OkConsumed (result, ("",_)) -> Choice1Of2 result
  
  (* Parsing fails after reaching the end of the input string 
    (the parser is confused and cannot return an error message) *)
  | OkEmpty    (_, (text,(row, column)))  
  | OkConsumed (_, (text,(row, column)))  -> 
      if text = ""
        then mkErrorRes "end of input" (row+1) column ""
        else 
          let nextWord  = getNextWordOnError text
          mkErrorRes nextWord (row+1) column ""

  (* Parsing failed somewhere in the input string *)
  | FailEmpty    (expected, (row, column))      
  | FailConsumed (expected, (row, column))    -> 
    let lines = s.Split([|"\n";"\r\n"|], StringSplitOptions.None)
    let line = lines.[row]
    let errorText = line.Substring column
    if errorText = ""
      then mkErrorRes "end of input" (row+1) column expected
      else 
        let word = getNextWordOnError errorText
        mkErrorRes word (row+1) column expected

let list_to_string (f:'a -> string) (sep:string) (xs:'a list) : string =
  let rec inner acc xs =
    match xs with
    | [] -> acc
    | [x] -> acc + (f x)
    | (x::xs) -> inner (acc + (f x) + sep) xs
  "[" + (inner "" xs) + "]" 

// Determining multiple errors in a given program by splitting on separators
// (alternatives are to put more logic into the primary parser)
let from_string_find_errors p (s:string) =
  let attempted_parse =
    try Some (from_string p s)
    with 
      | _ -> None
  if attempted_parse.IsSome then
    attempted_parse, [||]
  else
    let separated = s.Split([|"|"|], System.StringSplitOptions.None)
    let directives_plus_chunk = separated.[0]
    //TODO: Keep directive rather than drop and concat (performance)
    let directive_plus_to_first_separator =
      directives_plus_chunk.Split([|"directive"|], System.StringSplitOptions.None)
      |> Seq.skip 1
      |> Seq.map(fun directive -> "directive " + directive)
    let fragments =
      Seq.concat [directive_plus_to_first_separator; (Seq.skip 1 separated)]
      |> Array.ofSeq
    //TODO: Just count newlines, not split (performance)
    let new_line_counts =
      fragments
      |> Seq.map(fun chunk -> (chunk.Split(lineSeparators, System.StringSplitOptions.None) |> Array.length) - 1)
      |> Array.ofSeq
    let look_up_row i =
      new_line_counts
      |> Seq.take i
      |> Seq.sum
    let errors_in_commands =
      let f i row = 
        if row = "" then
          None
        else
          match from_string_first_error p row with
          | Some(r,c) -> Some({row = (look_up_row i) + r + 1;column=c;text = row}) //+1 makes it 1 based
          | None -> None
      fragments
      |> Seq.mapi f
    //let easy_debug = errors_in_commands |> Array.ofSeq
    None, errors_in_commands |> Seq.choose id |> Array.ofSeq

type ParserBuilder () =
    member x.Bind (comp, func) = comp >>= func
    member x.Return (value) = preturn value
    member x.ReturnFrom (value: t<'a>) = value
    member x.Combine (expr1, expr2) = expr1 .>>. expr2
    member x.Delay (func: unit -> t<'a>) = func ()
    member x.Zero () = failParser "Zero"

let parse = new ParserBuilder ()